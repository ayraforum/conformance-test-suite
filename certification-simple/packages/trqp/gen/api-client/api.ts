/* tslint:disable */
/* eslint-disable */
/**
 * ToIP Trust Registry (Query) Protocol v2 - Working Draft
 * # Trust Registry capabilities * Allow querying for critical items in a digital trust ecosystem: Entities, Registries, and Resources that are required to operate in the ecosysystem. # Registry of Registries (RoR) capabilities. RoR capabilities include:   * Listing Registries that are known (to the registry being queried).   * list the acknowledged trust registries that the RoR recognizes and what that may mean in the context of a particular governance framework. 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: darrell.odonnell@continuumloop.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Creates assurance level as a top-level/first-class-citizen of a Trust Registry. AssuranceLevel values MUST be defined in an EGF if they are used. 
 * @export
 * @interface AssuranceLevelType
 */
export interface AssuranceLevelType {
    /**
     * 
     * @type {string}
     * @memberof AssuranceLevelType
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof AssuranceLevelType
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AssuranceLevelType
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface AuthorizationResponseType
 */
export interface AuthorizationResponseType {
    /**
     * The VID that identifies the Entity that may (i.e. it may be expired, revoked, terminated)  hold the particular Authorization. 
     * @type {string}
     * @memberof AuthorizationResponseType
     */
    'entityID': string;
    /**
     * The unique string that identifies the Authorization.
     * @type {string}
     * @memberof AuthorizationResponseType
     */
    'authorizationUniqueString': string;
    /**
     * the VID that identifies the particular Authorization.
     * @type {string}
     * @memberof AuthorizationResponseType
     */
    'authorizationID'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationResponseType
     */
    'description': string;
    /**
     * The Assurance Level for the Authorization. Defined in the EGF. [OPTIONAL]
     * @type {AssuranceLevelType}
     * @memberof AuthorizationResponseType
     */
    'assuranceLevel'?: AssuranceLevelType;
    /**
     * 
     * @type {StatusType}
     * @memberof AuthorizationResponseType
     */
    'authorizationStatus'?: StatusType;
    /**
     * The Validity dates related to this particular authorization.
     * @type {ValidityDatesType}
     * @memberof AuthorizationResponseType
     */
    'authorizationValidity'?: ValidityDatesType;
}
/**
 * 
 * @export
 * @interface AuthorizationType
 */
export interface AuthorizationType {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationType
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationType
     */
    'simplename': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationType
     */
    'description': string;
    /**
     * The Assurance Level for the Authorization. Defined in the EGF. [OPTIONAL]
     * @type {AssuranceLevelType}
     * @memberof AuthorizationType
     */
    'assuranceLevel'?: AssuranceLevelType;
}
/**
 * 
 * @export
 * @interface EntityType
 */
export interface EntityType {
    /**
     * The primary identifier for the Entity (i.e. the primary key)
     * @type {string}
     * @memberof EntityType
     */
    'entityVID'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityType
     */
    'governanceFrameworkVID': string;
    /**
     * A VID identifying the registered entity\'s Primary Trust Registry
     * @type {string}
     * @memberof EntityType
     */
    'primaryTrustRegistryVID'?: string;
    /**
     * 
     * @type {Array<AuthorizationType>}
     * @memberof EntityType
     */
    'authorizations'?: Array<AuthorizationType>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityType
     */
    'secondaryTrustRegistries'?: Array<string>;
    /**
     * 
     * @type {Array<NamespaceType>}
     * @memberof EntityType
     */
    'participatingNamepaces'?: Array<NamespaceType>;
    /**
     * 
     * @type {ValidityDatesType}
     * @memberof EntityType
     */
    'entityDataValidity'?: ValidityDatesType;
    /**
     * 
     * @type {StatusType}
     * @memberof EntityType
     */
    'registrationStatus'?: StatusType;
}
/**
 * 
 * @export
 * @interface ExportFile
 */
export interface ExportFile {
    /**
     * The time of the data extraction.
     * @type {string}
     * @memberof ExportFile
     */
    'extractdatetime': string;
    /**
     * Version string [OPTIONAL]
     * @type {string}
     * @memberof ExportFile
     */
    'version'?: string;
    /**
     * 
     * @type {ValidityDatesType}
     * @memberof ExportFile
     */
    'validity'?: ValidityDatesType;
    /**
     * 
     * @type {ExportLookups}
     * @memberof ExportFile
     */
    'lookups'?: ExportLookups;
    /**
     * Array of RegistryQueryType
     * @type {Array<RegistryType>}
     * @memberof ExportFile
     */
    'registries'?: Array<RegistryType>;
    /**
     * 
     * @type {Array<EntityType>}
     * @memberof ExportFile
     */
    'entities'?: Array<EntityType>;
    /**
     * Array of RegistryQueryType
     * @type {Array<RegistryType>}
     * @memberof ExportFile
     */
    'resources'?: Array<RegistryType>;
}
/**
 * 
 * @export
 * @interface ExportLookups
 */
export interface ExportLookups {
    /**
     * 
     * @type {Array<VIDMethodType>}
     * @memberof ExportLookups
     */
    'VIDMethods'?: Array<VIDMethodType>;
    /**
     * 
     * @type {Array<AssuranceLevelType>}
     * @memberof ExportLookups
     */
    'AssuranceLevels'?: Array<AssuranceLevelType>;
    /**
     * 
     * @type {Array<AuthorizationType>}
     * @memberof ExportLookups
     */
    'Authorizations'?: Array<AuthorizationType>;
    /**
     * 
     * @type {Array<NamespaceType>}
     * @memberof ExportLookups
     */
    'Namespaces'?: Array<NamespaceType>;
}
/**
 * Integrity object
 * @export
 * @interface IntegrityType
 */
export interface IntegrityType {
    /**
     * Hashing algorithm well-known-name. TODO: Reference to some list? 
     * @type {string}
     * @memberof IntegrityType
     */
    'hashtype': string;
    /**
     * the hash of the data.
     * @type {string}
     * @memberof IntegrityType
     */
    'hash': string;
}
/**
 * Namespace object - formal name, EGF that governs namespace, VC/DIDAuth/etc. 
 * @export
 * @interface NamespaceType
 */
export interface NamespaceType {
    /**
     * 
     * @type {string}
     * @memberof NamespaceType
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof NamespaceType
     */
    'canonicalString': string;
    /**
     * URI of the EGF that defines the namespace.
     * @type {string}
     * @memberof NamespaceType
     */
    'egfURI'?: string;
    /**
     * 
     * @type {string}
     * @memberof NamespaceType
     */
    'description'?: string;
}
/**
 * A Problem Details object (RFC 7807)
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    /**
     * An absolute URI that identifies the problem type
     * @type {string}
     * @memberof ProblemDetails
     */
    'type'?: string;
    /**
     * A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
     * @type {string}
     * @memberof ProblemDetails
     */
    'title'?: string;
    /**
     * The HTTP status code generated by the origin server for this occurrence of the problem.
     * @type {number}
     * @memberof ProblemDetails
     */
    'status'?: number;
    /**
     * A human-readable explanation specific to this occurrence of the problem
     * @type {string}
     * @memberof ProblemDetails
     */
    'detail'?: string;
    /**
     * An absolute URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     * @type {string}
     * @memberof ProblemDetails
     */
    'instance'?: string;
}
/**
 * @type RegistriesRegistryVIDGet200Response
 * @export
 */
export type RegistriesRegistryVIDGet200Response = ResourceDirectType | ResourceReferencedType;

/**
 * 
 * @export
 * @interface RegistryMetadataType
 */
export interface RegistryMetadataType {
    /**
     * 
     * @type {string}
     * @memberof RegistryMetadataType
     */
    'lastupdated': string;
    /**
     * URI of the EGF that governs the Trust Registry.
     * @type {string}
     * @memberof RegistryMetadataType
     */
    'primaryEGFURI'?: string;
    /**
     * List of URIs of Ecosystem Governance Frameworks that this Trust Registry operates under, in addition to the .primaryEGFURI
     * @type {Array<string>}
     * @memberof RegistryMetadataType
     */
    'additionalEGFURIs'?: Array<string>;
    /**
     * 
     * @type {Array<NamespaceType>}
     * @memberof RegistryMetadataType
     */
    'participatingNamepaces'?: Array<NamespaceType>;
    /**
     * language codes (RFC 4646 - https://datatracker.ietf.org/doc/html/rfc4646)
     * @type {Array<string>}
     * @memberof RegistryMetadataType
     */
    'languages'?: Array<string>;
}
/**
 * Data structure for basic Trust Registry indication of what the queried TR will state about another TR. 
 * @export
 * @interface RegistryType
 */
export interface RegistryType {
    /**
     * 
     * @type {string}
     * @memberof RegistryType
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof RegistryType
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RegistryType
     */
    'description'?: string;
    /**
     * URI of the EGF that governs the Trust Registry.
     * @type {string}
     * @memberof RegistryType
     */
    'primaryEGFURI'?: string;
    /**
     * List of URIs of Ecosystem Governance Frameworks that this Trust Registry operates under, in addition to the .primaryEGFURI
     * @type {Array<string>}
     * @memberof RegistryType
     */
    'additionalEGFURIs'?: Array<string>;
    /**
     * 
     * @type {Array<NamespaceType>}
     * @memberof RegistryType
     */
    'participatingNamepaces'?: Array<NamespaceType>;
    /**
     * Relationship types - how does the TR that is being queried consider the other TR.   * peer - registy is recognized as a peer under another jurisdiction or governance mechanism.   * superior - registry is above this TR in a hierarchy.   * subordinate - registry is subordinate to this TR in a hierarchy.   * metaregistry - registry being queried is considered (by this TR) to be a metaregistry (aka registry of registries) 
     * @type {string}
     * @memberof RegistryType
     */
    'peerType'?: RegistryTypePeerTypeEnum;
}

export const RegistryTypePeerTypeEnum = {
    Peer: 'peer',
    Superior: 'superior',
    Subordinate: 'subordinate',
    Metaregistry: 'metaregistry'
} as const;

export type RegistryTypePeerTypeEnum = typeof RegistryTypePeerTypeEnum[keyof typeof RegistryTypePeerTypeEnum];

/**
 * Resource that is served directly by this trust registry.
 * @export
 * @interface ResourceDirectType
 */
export interface ResourceDirectType {
    /**
     * 
     * @type {string}
     * @memberof ResourceDirectType
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDirectType
     */
    'lastupdated': string;
    /**
     * TODO: DECIDE about mimeType vs. dataType as property name The `kind` of resource (e.g. credential-definition, schema-definition, revocation-registry). intended to be used by recipient for processing of the data payload. 
     * @type {string}
     * @memberof ResourceDirectType
     */
    'datatype': string;
    /**
     * string providing an URI formatted according to IETF RFC 3986.
     * @type {string}
     * @memberof ResourceDirectType
     */
    'resourceURI'?: string;
    /**
     * JSON object
     * @type {object}
     * @memberof ResourceDirectType
     */
    'payloadJSON'?: object;
}
/**
 * Resource that is provided by reference to a different source.
 * @export
 * @interface ResourceReferencedType
 */
export interface ResourceReferencedType {
    /**
     * 
     * @type {string}
     * @memberof ResourceReferencedType
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceReferencedType
     */
    'lastupdated': string;
    /**
     * TODO: DECIDE about mimeType vs. dataType as property name The `kind` of resource (e.g. credential-definition, schema-definition, revocation-registry). intended to be used by recipient for processing of the data payload. 
     * @type {string}
     * @memberof ResourceReferencedType
     */
    'datatype': string;
    /**
     * string providing an URI formatted according to IETF RFC 3986.
     * @type {string}
     * @memberof ResourceReferencedType
     */
    'resourceURI': string;
    /**
     * 
     * @type {IntegrityType}
     * @memberof ResourceReferencedType
     */
    'integrity'?: IntegrityType;
}
/**
 * Status and textual description for Entity Registration Status, and Entity Authorization Status
 * @export
 * @interface StatusType
 */
export interface StatusType {
    /**
     * Provides a current status for entity at time of the query. - current - status is current in the system of record. - expired - status has expired in the system of record. - terminated - entity has voluntarily terminated its status. - revoked -  status was revoked by the governing authority. 
     * @type {string}
     * @memberof StatusType
     */
    'status': StatusTypeStatusEnum;
    /**
     * Optional free text that expands on the status parameter.
     * @type {string}
     * @memberof StatusType
     */
    'detail'?: string;
}

export const StatusTypeStatusEnum = {
    Current: 'current',
    Expired: 'expired',
    Terminated: 'terminated',
    Revoked: 'revoked'
} as const;

export type StatusTypeStatusEnum = typeof StatusTypeStatusEnum[keyof typeof StatusTypeStatusEnum];

/**
 * Trust Establishment Document per https://identity.foundation/trust-establishment/
 * @export
 * @interface TrustEstablishmentDocument
 */
export interface TrustEstablishmentDocument {
    /**
     * 
     * @type {string}
     * @memberof TrustEstablishmentDocument
     */
    'TBD': string;
}
/**
 * DID Method supported by the trust registry. May include the maximum 
 * @export
 * @interface VIDMethodType
 */
export interface VIDMethodType {
    /**
     * as \"maintained\" at https://w3c.github.io/did-spec-registries/#did-methods TODO: do better... 
     * @type {string}
     * @memberof VIDMethodType
     */
    'identifier': string;
    /**
     * A DID Method may, due to technical or human trust considerations be limited in the assurance level that it can provide. 
     * @type {AssuranceLevelType}
     * @memberof VIDMethodType
     */
    'maximumAssuranceLevel'?: AssuranceLevelType;
}
/**
 * Date and Time of validity.
 * @export
 * @interface ValidityDatesType
 */
export interface ValidityDatesType {
    /**
     * Indicates that the Identifier status applies at the indicated time. A time in the past indicates when the last status change was recorded in the Trust Registry.
     * @type {string}
     * @memberof ValidityDatesType
     */
    'validFromDT'?: string;
    /**
     * Indicates the validity ends/ended at this date and time. A time in the past may indicate that the data have expired. A blank response indicates that the validity does not have an end value (i.e. does not or has not expired yet).
     * @type {string}
     * @memberof ValidityDatesType
     */
    'validUntilDT'?: string;
}

/**
 * LookupsApi - axios parameter creator
 * @export
 */
export const LookupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of the assurance levels that are in use by this Trust Registry (and its governing EGF).
         * @param {string} egfURI The URI-based identifier of the Ecosystem Governance Framework that the assurance levels apply to. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssurancelevelsGet: async (egfURI: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'egfURI' is not null or undefined
            assertParamExists('lookupAssurancelevelsGet', 'egfURI', egfURI)
            const localVarPath = `/lookup/assurancelevels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (egfURI !== undefined) {
                localVarQueryParameter['egfURI'] = egfURI;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of Rights that are used in this Trust Registry.
         * @param {string} egfURI The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAuthorizationsGet: async (egfURI: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'egfURI' is not null or undefined
            assertParamExists('lookupAuthorizationsGet', 'egfURI', egfURI)
            const localVarPath = `/lookup/authorizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (egfURI !== undefined) {
                localVarQueryParameter['egfURI'] = egfURI;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the namespaces that are supported in this trust Registry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupNamespacesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lookup/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of DID Methods that are supported by a particular Governance Framework.
         * @param {Array<VIDMethodType>} egfURI Provides a list of DID-methods that are supported by this trust registry. MAY include Maximum Assurance Level that a DID Method is set at under the EGF. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupVidmethodsGet: async (egfURI: Array<VIDMethodType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'egfURI' is not null or undefined
            assertParamExists('lookupVidmethodsGet', 'egfURI', egfURI)
            const localVarPath = `/lookup/vidmethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (egfURI) {
                localVarQueryParameter['egfURI'] = egfURI;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LookupsApi - functional programming interface
 * @export
 */
export const LookupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LookupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of the assurance levels that are in use by this Trust Registry (and its governing EGF).
         * @param {string} egfURI The URI-based identifier of the Ecosystem Governance Framework that the assurance levels apply to. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAssurancelevelsGet(egfURI: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssuranceLevelType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAssurancelevelsGet(egfURI, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LookupsApi.lookupAssurancelevelsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of Rights that are used in this Trust Registry.
         * @param {string} egfURI The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupAuthorizationsGet(egfURI: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthorizationType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupAuthorizationsGet(egfURI, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LookupsApi.lookupAuthorizationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the namespaces that are supported in this trust Registry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupNamespacesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NamespaceType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupNamespacesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LookupsApi.lookupNamespacesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of DID Methods that are supported by a particular Governance Framework.
         * @param {Array<VIDMethodType>} egfURI Provides a list of DID-methods that are supported by this trust registry. MAY include Maximum Assurance Level that a DID Method is set at under the EGF. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupVidmethodsGet(egfURI: Array<VIDMethodType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VIDMethodType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupVidmethodsGet(egfURI, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LookupsApi.lookupVidmethodsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LookupsApi - factory interface
 * @export
 */
export const LookupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LookupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of the assurance levels that are in use by this Trust Registry (and its governing EGF).
         * @param {string} egfURI The URI-based identifier of the Ecosystem Governance Framework that the assurance levels apply to. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssurancelevelsGet(egfURI: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AssuranceLevelType>> {
            return localVarFp.lookupAssurancelevelsGet(egfURI, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of Rights that are used in this Trust Registry.
         * @param {string} egfURI The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAuthorizationsGet(egfURI: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AuthorizationType>> {
            return localVarFp.lookupAuthorizationsGet(egfURI, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the namespaces that are supported in this trust Registry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupNamespacesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<NamespaceType>> {
            return localVarFp.lookupNamespacesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of DID Methods that are supported by a particular Governance Framework.
         * @param {Array<VIDMethodType>} egfURI Provides a list of DID-methods that are supported by this trust registry. MAY include Maximum Assurance Level that a DID Method is set at under the EGF. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupVidmethodsGet(egfURI: Array<VIDMethodType>, options?: RawAxiosRequestConfig): AxiosPromise<Array<VIDMethodType>> {
            return localVarFp.lookupVidmethodsGet(egfURI, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LookupsApi - object-oriented interface
 * @export
 * @class LookupsApi
 * @extends {BaseAPI}
 */
export class LookupsApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of the assurance levels that are in use by this Trust Registry (and its governing EGF).
     * @param {string} egfURI The URI-based identifier of the Ecosystem Governance Framework that the assurance levels apply to. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LookupsApi
     */
    public lookupAssurancelevelsGet(egfURI: string, options?: RawAxiosRequestConfig) {
        return LookupsApiFp(this.configuration).lookupAssurancelevelsGet(egfURI, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of Rights that are used in this Trust Registry.
     * @param {string} egfURI The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LookupsApi
     */
    public lookupAuthorizationsGet(egfURI: string, options?: RawAxiosRequestConfig) {
        return LookupsApiFp(this.configuration).lookupAuthorizationsGet(egfURI, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the namespaces that are supported in this trust Registry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LookupsApi
     */
    public lookupNamespacesGet(options?: RawAxiosRequestConfig) {
        return LookupsApiFp(this.configuration).lookupNamespacesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of DID Methods that are supported by a particular Governance Framework.
     * @param {Array<VIDMethodType>} egfURI Provides a list of DID-methods that are supported by this trust registry. MAY include Maximum Assurance Level that a DID Method is set at under the EGF. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LookupsApi
     */
    public lookupVidmethodsGet(egfURI: Array<VIDMethodType>, options?: RawAxiosRequestConfig) {
        return LookupsApiFp(this.configuration).lookupVidmethodsGet(egfURI, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Metadata object.
         * @summary Provides metadata object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * Metadata object.
         * @summary Provides metadata object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metadataGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryMetadataType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metadataGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.metadataGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * Metadata object.
         * @summary Provides metadata object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataGet(options?: RawAxiosRequestConfig): AxiosPromise<RegistryMetadataType> {
            return localVarFp.metadataGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
    /**
     * Metadata object.
     * @summary Provides metadata object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public metadataGet(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).metadataGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OfflineApi - axios parameter creator
 * @export
 */
export const OfflineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under. 
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfflineFile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/offline/exportfile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under. 
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTED: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/offline/trustestablishmentdocument`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OfflineApi - functional programming interface
 * @export
 */
export const OfflineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OfflineApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under. 
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfflineFile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOfflineFile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfflineApi.getOfflineFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under. 
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTED(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrustEstablishmentDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTED(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfflineApi.getTED']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OfflineApi - factory interface
 * @export
 */
export const OfflineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OfflineApiFp(configuration)
    return {
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under. 
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfflineFile(options?: RawAxiosRequestConfig): AxiosPromise<ExportFile> {
            return localVarFp.getOfflineFile(options).then((request) => request(axios, basePath));
        },
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under. 
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTED(options?: RawAxiosRequestConfig): AxiosPromise<TrustEstablishmentDocument> {
            return localVarFp.getTED(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OfflineApi - object-oriented interface
 * @export
 * @class OfflineApi
 * @extends {BaseAPI}
 */
export class OfflineApi extends BaseAPI {
    /**
     * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under. 
     * @summary Access a full data file that can be used offline.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfflineApi
     */
    public getOfflineFile(options?: RawAxiosRequestConfig) {
        return OfflineApiFp(this.configuration).getOfflineFile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under. 
     * @summary Access a full data file that can be used offline.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfflineApi
     */
    public getTED(options?: RawAxiosRequestConfig) {
        return OfflineApiFp(this.configuration).getTED(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RegistryApi - axios parameter creator
 * @export
 */
export const RegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entitiesEntityVIDAuthorizationGet: async (entityVID: string, authorizationVID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityVID' is not null or undefined
            assertParamExists('entitiesEntityVIDAuthorizationGet', 'entityVID', entityVID)
            const localVarPath = `/entities/{entityVID}/authorization`
                .replace(`{${"entityVID"}}`, encodeURIComponent(String(entityVID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorizationVID !== undefined) {
                localVarQueryParameter['authorizationVID'] = authorizationVID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entitiesEntityVIDAuthorizationsGet: async (entityVID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityVID' is not null or undefined
            assertParamExists('entitiesEntityVIDAuthorizationsGet', 'entityVID', entityVID)
            const localVarPath = `/entities/{entityVID}/authorizations`
                .replace(`{${"entityVID"}}`, encodeURIComponent(String(entityVID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns Registry Information about a particular entity that is represented in the queried system.
         * @param {string} entityid The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entititiesEntityidGet: async (entityid: string, authorizationVID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityid' is not null or undefined
            assertParamExists('entititiesEntityidGet', 'entityid', entityid)
            const localVarPath = `/entitities/{entityid}`
                .replace(`{${"entityid"}}`, encodeURIComponent(String(entityid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorizationVID !== undefined) {
                localVarQueryParameter['authorizationVID'] = authorizationVID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query this Trust Registry about its recognition of another Trust Registry. 
         * @param {string} [namespaceVID] Filter in only the namespace requested - show all registries otherwise. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {string} [eGFVID] Filter in only the registries under the specified EGF (by EGF DID). Defaults to be limited to the EGFURI that is being queried at the root. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRecognizedRegistriesGet: async (namespaceVID?: string, eGFVID?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/registries/recognized-registries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (namespaceVID !== undefined) {
                localVarQueryParameter['namespace-VID'] = namespaceVID;
            }

            if (eGFVID !== undefined) {
                localVarQueryParameter['EGF-VID'] = eGFVID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get resource data indicated by DID.
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRegistryVIDGet: async (registryVID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registryVID' is not null or undefined
            assertParamExists('registriesRegistryVIDGet', 'registryVID', registryVID)
            const localVarPath = `/registries/{registryVID}/`
                .replace(`{${"registryVID"}}`, encodeURIComponent(String(registryVID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query this Trust Registry about its recognition of a specific Trust Registry. TODO: determine RoR (registry of registry) impacts here. 
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRegistryVIDRecognizedRegistriesGet: async (registryVID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registryVID' is not null or undefined
            assertParamExists('registriesRegistryVIDRecognizedRegistriesGet', 'registryVID', registryVID)
            const localVarPath = `/registries/{registryVID}/recognized-registries/`
                .replace(`{${"registryVID"}}`, encodeURIComponent(String(registryVID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryApi - functional programming interface
 * @export
 */
export const RegistryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entitiesEntityVIDAuthorizationGet(entityVID: string, authorizationVID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthorizationResponseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entitiesEntityVIDAuthorizationGet(entityVID, authorizationVID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.entitiesEntityVIDAuthorizationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entitiesEntityVIDAuthorizationsGet(entityVID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthorizationResponseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entitiesEntityVIDAuthorizationsGet(entityVID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.entitiesEntityVIDAuthorizationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns Registry Information about a particular entity that is represented in the queried system.
         * @param {string} entityid The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entititiesEntityidGet(entityid: string, authorizationVID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entititiesEntityidGet(entityid, authorizationVID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.entititiesEntityidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query this Trust Registry about its recognition of another Trust Registry. 
         * @param {string} [namespaceVID] Filter in only the namespace requested - show all registries otherwise. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {string} [eGFVID] Filter in only the registries under the specified EGF (by EGF DID). Defaults to be limited to the EGFURI that is being queried at the root. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesRecognizedRegistriesGet(namespaceVID?: string, eGFVID?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registriesRecognizedRegistriesGet(namespaceVID, eGFVID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registriesRecognizedRegistriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get resource data indicated by DID.
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesRegistryVIDGet(registryVID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistriesRegistryVIDGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registriesRegistryVIDGet(registryVID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registriesRegistryVIDGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query this Trust Registry about its recognition of a specific Trust Registry. TODO: determine RoR (registry of registry) impacts here. 
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registriesRegistryVIDRecognizedRegistriesGet(registryVID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registriesRegistryVIDRecognizedRegistriesGet(registryVID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegistryApi.registriesRegistryVIDRecognizedRegistriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RegistryApi - factory interface
 * @export
 */
export const RegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistryApiFp(configuration)
    return {
        /**
         * 
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entitiesEntityVIDAuthorizationGet(entityVID: string, authorizationVID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AuthorizationResponseType>> {
            return localVarFp.entitiesEntityVIDAuthorizationGet(entityVID, authorizationVID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entitiesEntityVIDAuthorizationsGet(entityVID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AuthorizationResponseType>> {
            return localVarFp.entitiesEntityVIDAuthorizationsGet(entityVID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns Registry Information about a particular entity that is represented in the queried system.
         * @param {string} entityid The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entititiesEntityidGet(entityid: string, authorizationVID?: string, options?: RawAxiosRequestConfig): AxiosPromise<EntityType> {
            return localVarFp.entititiesEntityidGet(entityid, authorizationVID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query this Trust Registry about its recognition of another Trust Registry. 
         * @param {string} [namespaceVID] Filter in only the namespace requested - show all registries otherwise. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {string} [eGFVID] Filter in only the registries under the specified EGF (by EGF DID). Defaults to be limited to the EGFURI that is being queried at the root. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRecognizedRegistriesGet(namespaceVID?: string, eGFVID?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RegistryType>> {
            return localVarFp.registriesRecognizedRegistriesGet(namespaceVID, eGFVID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get resource data indicated by DID.
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRegistryVIDGet(registryVID: string, options?: RawAxiosRequestConfig): AxiosPromise<RegistriesRegistryVIDGet200Response> {
            return localVarFp.registriesRegistryVIDGet(registryVID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query this Trust Registry about its recognition of a specific Trust Registry. TODO: determine RoR (registry of registry) impacts here. 
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRegistryVIDRecognizedRegistriesGet(registryVID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RegistryType>> {
            return localVarFp.registriesRegistryVIDRecognizedRegistriesGet(registryVID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
export class RegistryApi extends BaseAPI {
    /**
     * 
     * @summary Determine whether an Entity has a particular Authorization.
     * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
     * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public entitiesEntityVIDAuthorizationGet(entityVID: string, authorizationVID?: string, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).entitiesEntityVIDAuthorizationGet(entityVID, authorizationVID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Determine whether an Entity has a particular Authorization.
     * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public entitiesEntityVIDAuthorizationsGet(entityVID: string, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).entitiesEntityVIDAuthorizationsGet(entityVID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns Registry Information about a particular entity that is represented in the queried system.
     * @param {string} entityid The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
     * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public entititiesEntityidGet(entityid: string, authorizationVID?: string, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).entititiesEntityidGet(entityid, authorizationVID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query this Trust Registry about its recognition of another Trust Registry. 
     * @param {string} [namespaceVID] Filter in only the namespace requested - show all registries otherwise. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
     * @param {string} [eGFVID] Filter in only the registries under the specified EGF (by EGF DID). Defaults to be limited to the EGFURI that is being queried at the root. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public registriesRecognizedRegistriesGet(namespaceVID?: string, eGFVID?: string, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registriesRecognizedRegistriesGet(namespaceVID, eGFVID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get resource data indicated by DID.
     * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public registriesRegistryVIDGet(registryVID: string, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registriesRegistryVIDGet(registryVID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query this Trust Registry about its recognition of a specific Trust Registry. TODO: determine RoR (registry of registry) impacts here. 
     * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public registriesRegistryVIDRecognizedRegistriesGet(registryVID: string, options?: RawAxiosRequestConfig) {
        return RegistryApiFp(this.configuration).registriesRegistryVIDRecognizedRegistriesGet(registryVID, options).then((request) => request(this.axios, this.basePath));
    }
}



