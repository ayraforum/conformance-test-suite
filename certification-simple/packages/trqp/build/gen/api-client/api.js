"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * ToIP Trust Registry (Query) Protocol v2 - Working Draft
 * # Trust Registry capabilities * Allow querying for critical items in a digital trust ecosystem: Entities, Registries, and Resources that are required to operate in the ecosysystem. # Registry of Registries (RoR) capabilities. RoR capabilities include:   * Listing Registries that are known (to the registry being queried).   * list the acknowledged trust registries that the RoR recognizes and what that may mean in the context of a particular governance framework.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: darrell.odonnell@continuumloop.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryApi = exports.RegistryApiFactory = exports.RegistryApiFp = exports.RegistryApiAxiosParamCreator = exports.OfflineApi = exports.OfflineApiFactory = exports.OfflineApiFp = exports.OfflineApiAxiosParamCreator = exports.MetadataApi = exports.MetadataApiFactory = exports.MetadataApiFp = exports.MetadataApiAxiosParamCreator = exports.LookupsApi = exports.LookupsApiFactory = exports.LookupsApiFp = exports.LookupsApiAxiosParamCreator = exports.StatusTypeStatusEnum = exports.RegistryTypePeerTypeEnum = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.RegistryTypePeerTypeEnum = {
    Peer: 'peer',
    Superior: 'superior',
    Subordinate: 'subordinate',
    Metaregistry: 'metaregistry'
};
exports.StatusTypeStatusEnum = {
    Current: 'current',
    Expired: 'expired',
    Terminated: 'terminated',
    Revoked: 'revoked'
};
/**
 * LookupsApi - axios parameter creator
 * @export
 */
const LookupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get a list of the assurance levels that are in use by this Trust Registry (and its governing EGF).
         * @param {string} egfURI The URI-based identifier of the Ecosystem Governance Framework that the assurance levels apply to. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssurancelevelsGet: (egfURI_1, ...args_1) => __awaiter(this, [egfURI_1, ...args_1], void 0, function* (egfURI, options = {}) {
            // verify required parameter 'egfURI' is not null or undefined
            (0, common_1.assertParamExists)('lookupAssurancelevelsGet', 'egfURI', egfURI);
            const localVarPath = `/lookup/assurancelevels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (egfURI !== undefined) {
                localVarQueryParameter['egfURI'] = egfURI;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a list of Rights that are used in this Trust Registry.
         * @param {string} egfURI The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAuthorizationsGet: (egfURI_1, ...args_1) => __awaiter(this, [egfURI_1, ...args_1], void 0, function* (egfURI, options = {}) {
            // verify required parameter 'egfURI' is not null or undefined
            (0, common_1.assertParamExists)('lookupAuthorizationsGet', 'egfURI', egfURI);
            const localVarPath = `/lookup/authorizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (egfURI !== undefined) {
                localVarQueryParameter['egfURI'] = egfURI;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the namespaces that are supported in this trust Registry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupNamespacesGet: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/lookup/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a list of DID Methods that are supported by a particular Governance Framework.
         * @param {Array<VIDMethodType>} egfURI Provides a list of DID-methods that are supported by this trust registry. MAY include Maximum Assurance Level that a DID Method is set at under the EGF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupVidmethodsGet: (egfURI_1, ...args_1) => __awaiter(this, [egfURI_1, ...args_1], void 0, function* (egfURI, options = {}) {
            // verify required parameter 'egfURI' is not null or undefined
            (0, common_1.assertParamExists)('lookupVidmethodsGet', 'egfURI', egfURI);
            const localVarPath = `/lookup/vidmethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (egfURI) {
                localVarQueryParameter['egfURI'] = egfURI;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.LookupsApiAxiosParamCreator = LookupsApiAxiosParamCreator;
/**
 * LookupsApi - functional programming interface
 * @export
 */
const LookupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LookupsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get a list of the assurance levels that are in use by this Trust Registry (and its governing EGF).
         * @param {string} egfURI The URI-based identifier of the Ecosystem Governance Framework that the assurance levels apply to. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssurancelevelsGet(egfURI, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.lookupAssurancelevelsGet(egfURI, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LookupsApi.lookupAssurancelevelsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a list of Rights that are used in this Trust Registry.
         * @param {string} egfURI The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAuthorizationsGet(egfURI, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.lookupAuthorizationsGet(egfURI, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LookupsApi.lookupAuthorizationsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get the namespaces that are supported in this trust Registry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupNamespacesGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.lookupNamespacesGet(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LookupsApi.lookupNamespacesGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a list of DID Methods that are supported by a particular Governance Framework.
         * @param {Array<VIDMethodType>} egfURI Provides a list of DID-methods that are supported by this trust registry. MAY include Maximum Assurance Level that a DID Method is set at under the EGF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupVidmethodsGet(egfURI, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.lookupVidmethodsGet(egfURI, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LookupsApi.lookupVidmethodsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.LookupsApiFp = LookupsApiFp;
/**
 * LookupsApi - factory interface
 * @export
 */
const LookupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LookupsApiFp)(configuration);
    return {
        /**
         *
         * @summary Get a list of the assurance levels that are in use by this Trust Registry (and its governing EGF).
         * @param {string} egfURI The URI-based identifier of the Ecosystem Governance Framework that the assurance levels apply to. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAssurancelevelsGet(egfURI, options) {
            return localVarFp.lookupAssurancelevelsGet(egfURI, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a list of Rights that are used in this Trust Registry.
         * @param {string} egfURI The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAuthorizationsGet(egfURI, options) {
            return localVarFp.lookupAuthorizationsGet(egfURI, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the namespaces that are supported in this trust Registry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupNamespacesGet(options) {
            return localVarFp.lookupNamespacesGet(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a list of DID Methods that are supported by a particular Governance Framework.
         * @param {Array<VIDMethodType>} egfURI Provides a list of DID-methods that are supported by this trust registry. MAY include Maximum Assurance Level that a DID Method is set at under the EGF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupVidmethodsGet(egfURI, options) {
            return localVarFp.lookupVidmethodsGet(egfURI, options).then((request) => request(axios, basePath));
        },
    };
};
exports.LookupsApiFactory = LookupsApiFactory;
/**
 * LookupsApi - object-oriented interface
 * @export
 * @class LookupsApi
 * @extends {BaseAPI}
 */
class LookupsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get a list of the assurance levels that are in use by this Trust Registry (and its governing EGF).
     * @param {string} egfURI The URI-based identifier of the Ecosystem Governance Framework that the assurance levels apply to. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LookupsApi
     */
    lookupAssurancelevelsGet(egfURI, options) {
        return (0, exports.LookupsApiFp)(this.configuration).lookupAssurancelevelsGet(egfURI, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a list of Rights that are used in this Trust Registry.
     * @param {string} egfURI The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LookupsApi
     */
    lookupAuthorizationsGet(egfURI, options) {
        return (0, exports.LookupsApiFp)(this.configuration).lookupAuthorizationsGet(egfURI, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the namespaces that are supported in this trust Registry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LookupsApi
     */
    lookupNamespacesGet(options) {
        return (0, exports.LookupsApiFp)(this.configuration).lookupNamespacesGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a list of DID Methods that are supported by a particular Governance Framework.
     * @param {Array<VIDMethodType>} egfURI Provides a list of DID-methods that are supported by this trust registry. MAY include Maximum Assurance Level that a DID Method is set at under the EGF.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LookupsApi
     */
    lookupVidmethodsGet(egfURI, options) {
        return (0, exports.LookupsApiFp)(this.configuration).lookupVidmethodsGet(egfURI, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LookupsApi = LookupsApi;
/**
 * MetadataApi - axios parameter creator
 * @export
 */
const MetadataApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Metadata object.
         * @summary Provides metadata object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataGet: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.MetadataApiAxiosParamCreator = MetadataApiAxiosParamCreator;
/**
 * MetadataApi - functional programming interface
 * @export
 */
const MetadataApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.MetadataApiAxiosParamCreator)(configuration);
    return {
        /**
         * Metadata object.
         * @summary Provides metadata object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.metadataGet(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['MetadataApi.metadataGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.MetadataApiFp = MetadataApiFp;
/**
 * MetadataApi - factory interface
 * @export
 */
const MetadataApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.MetadataApiFp)(configuration);
    return {
        /**
         * Metadata object.
         * @summary Provides metadata object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataGet(options) {
            return localVarFp.metadataGet(options).then((request) => request(axios, basePath));
        },
    };
};
exports.MetadataApiFactory = MetadataApiFactory;
/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
class MetadataApi extends base_1.BaseAPI {
    /**
     * Metadata object.
     * @summary Provides metadata object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    metadataGet(options) {
        return (0, exports.MetadataApiFp)(this.configuration).metadataGet(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.MetadataApi = MetadataApi;
/**
 * OfflineApi - axios parameter creator
 * @export
 */
const OfflineApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under.
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfflineFile: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/offline/exportfile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under.
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTED: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/offline/trustestablishmentdocument`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.OfflineApiAxiosParamCreator = OfflineApiAxiosParamCreator;
/**
 * OfflineApi - functional programming interface
 * @export
 */
const OfflineApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.OfflineApiAxiosParamCreator)(configuration);
    return {
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under.
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfflineFile(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOfflineFile(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OfflineApi.getOfflineFile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under.
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTED(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTED(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OfflineApi.getTED']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.OfflineApiFp = OfflineApiFp;
/**
 * OfflineApi - factory interface
 * @export
 */
const OfflineApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.OfflineApiFp)(configuration);
    return {
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under.
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOfflineFile(options) {
            return localVarFp.getOfflineFile(options).then((request) => request(axios, basePath));
        },
        /**
         * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under.
         * @summary Access a full data file that can be used offline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTED(options) {
            return localVarFp.getTED(options).then((request) => request(axios, basePath));
        },
    };
};
exports.OfflineApiFactory = OfflineApiFactory;
/**
 * OfflineApi - object-oriented interface
 * @export
 * @class OfflineApi
 * @extends {BaseAPI}
 */
class OfflineApi extends base_1.BaseAPI {
    /**
     * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under.
     * @summary Access a full data file that can be used offline.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfflineApi
     */
    getOfflineFile(options) {
        return (0, exports.OfflineApiFp)(this.configuration).getOfflineFile(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows querying to determine the status of an Issuer, as identified by their Identifier (unique), credential type, and EGF that they are operating under.
     * @summary Access a full data file that can be used offline.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfflineApi
     */
    getTED(options) {
        return (0, exports.OfflineApiFp)(this.configuration).getTED(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OfflineApi = OfflineApi;
/**
 * RegistryApi - axios parameter creator
 * @export
 */
const RegistryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entitiesEntityVIDAuthorizationGet: (entityVID_1, authorizationVID_1, ...args_1) => __awaiter(this, [entityVID_1, authorizationVID_1, ...args_1], void 0, function* (entityVID, authorizationVID, options = {}) {
            // verify required parameter 'entityVID' is not null or undefined
            (0, common_1.assertParamExists)('entitiesEntityVIDAuthorizationGet', 'entityVID', entityVID);
            const localVarPath = `/entities/{entityVID}/authorization`
                .replace(`{${"entityVID"}}`, encodeURIComponent(String(entityVID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (authorizationVID !== undefined) {
                localVarQueryParameter['authorizationVID'] = authorizationVID;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entitiesEntityVIDAuthorizationsGet: (entityVID_1, ...args_1) => __awaiter(this, [entityVID_1, ...args_1], void 0, function* (entityVID, options = {}) {
            // verify required parameter 'entityVID' is not null or undefined
            (0, common_1.assertParamExists)('entitiesEntityVIDAuthorizationsGet', 'entityVID', entityVID);
            const localVarPath = `/entities/{entityVID}/authorizations`
                .replace(`{${"entityVID"}}`, encodeURIComponent(String(entityVID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Returns Registry Information about a particular entity that is represented in the queried system.
         * @param {string} entityid The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entititiesEntityidGet: (entityid_1, authorizationVID_1, ...args_1) => __awaiter(this, [entityid_1, authorizationVID_1, ...args_1], void 0, function* (entityid, authorizationVID, options = {}) {
            // verify required parameter 'entityid' is not null or undefined
            (0, common_1.assertParamExists)('entititiesEntityidGet', 'entityid', entityid);
            const localVarPath = `/entitities/{entityid}`
                .replace(`{${"entityid"}}`, encodeURIComponent(String(entityid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (authorizationVID !== undefined) {
                localVarQueryParameter['authorizationVID'] = authorizationVID;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Query this Trust Registry about its recognition of another Trust Registry.
         * @param {string} [namespaceVID] Filter in only the namespace requested - show all registries otherwise. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {string} [eGFVID] Filter in only the registries under the specified EGF (by EGF DID). Defaults to be limited to the EGFURI that is being queried at the root. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRecognizedRegistriesGet: (namespaceVID_1, eGFVID_1, ...args_1) => __awaiter(this, [namespaceVID_1, eGFVID_1, ...args_1], void 0, function* (namespaceVID, eGFVID, options = {}) {
            const localVarPath = `/registries/recognized-registries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (namespaceVID !== undefined) {
                localVarQueryParameter['namespace-VID'] = namespaceVID;
            }
            if (eGFVID !== undefined) {
                localVarQueryParameter['EGF-VID'] = eGFVID;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get resource data indicated by DID.
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRegistryVIDGet: (registryVID_1, ...args_1) => __awaiter(this, [registryVID_1, ...args_1], void 0, function* (registryVID, options = {}) {
            // verify required parameter 'registryVID' is not null or undefined
            (0, common_1.assertParamExists)('registriesRegistryVIDGet', 'registryVID', registryVID);
            const localVarPath = `/registries/{registryVID}/`
                .replace(`{${"registryVID"}}`, encodeURIComponent(String(registryVID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Query this Trust Registry about its recognition of a specific Trust Registry. TODO: determine RoR (registry of registry) impacts here.
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRegistryVIDRecognizedRegistriesGet: (registryVID_1, ...args_1) => __awaiter(this, [registryVID_1, ...args_1], void 0, function* (registryVID, options = {}) {
            // verify required parameter 'registryVID' is not null or undefined
            (0, common_1.assertParamExists)('registriesRegistryVIDRecognizedRegistriesGet', 'registryVID', registryVID);
            const localVarPath = `/registries/{registryVID}/recognized-registries/`
                .replace(`{${"registryVID"}}`, encodeURIComponent(String(registryVID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RegistryApiAxiosParamCreator = RegistryApiAxiosParamCreator;
/**
 * RegistryApi - functional programming interface
 * @export
 */
const RegistryApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RegistryApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entitiesEntityVIDAuthorizationGet(entityVID, authorizationVID, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.entitiesEntityVIDAuthorizationGet(entityVID, authorizationVID, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RegistryApi.entitiesEntityVIDAuthorizationGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entitiesEntityVIDAuthorizationsGet(entityVID, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.entitiesEntityVIDAuthorizationsGet(entityVID, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RegistryApi.entitiesEntityVIDAuthorizationsGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Returns Registry Information about a particular entity that is represented in the queried system.
         * @param {string} entityid The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entititiesEntityidGet(entityid, authorizationVID, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.entititiesEntityidGet(entityid, authorizationVID, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RegistryApi.entititiesEntityidGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Query this Trust Registry about its recognition of another Trust Registry.
         * @param {string} [namespaceVID] Filter in only the namespace requested - show all registries otherwise. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {string} [eGFVID] Filter in only the registries under the specified EGF (by EGF DID). Defaults to be limited to the EGFURI that is being queried at the root. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRecognizedRegistriesGet(namespaceVID, eGFVID, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registriesRecognizedRegistriesGet(namespaceVID, eGFVID, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RegistryApi.registriesRecognizedRegistriesGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get resource data indicated by DID.
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRegistryVIDGet(registryVID, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registriesRegistryVIDGet(registryVID, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RegistryApi.registriesRegistryVIDGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Query this Trust Registry about its recognition of a specific Trust Registry. TODO: determine RoR (registry of registry) impacts here.
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRegistryVIDRecognizedRegistriesGet(registryVID, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registriesRegistryVIDRecognizedRegistriesGet(registryVID, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RegistryApi.registriesRegistryVIDRecognizedRegistriesGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.RegistryApiFp = RegistryApiFp;
/**
 * RegistryApi - factory interface
 * @export
 */
const RegistryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RegistryApiFp)(configuration);
    return {
        /**
         *
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entitiesEntityVIDAuthorizationGet(entityVID, authorizationVID, options) {
            return localVarFp.entitiesEntityVIDAuthorizationGet(entityVID, authorizationVID, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Determine whether an Entity has a particular Authorization.
         * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entitiesEntityVIDAuthorizationsGet(entityVID, options) {
            return localVarFp.entitiesEntityVIDAuthorizationsGet(entityVID, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns Registry Information about a particular entity that is represented in the queried system.
         * @param {string} entityid The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entititiesEntityidGet(entityid, authorizationVID, options) {
            return localVarFp.entititiesEntityidGet(entityid, authorizationVID, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Query this Trust Registry about its recognition of another Trust Registry.
         * @param {string} [namespaceVID] Filter in only the namespace requested - show all registries otherwise. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {string} [eGFVID] Filter in only the registries under the specified EGF (by EGF DID). Defaults to be limited to the EGFURI that is being queried at the root. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRecognizedRegistriesGet(namespaceVID, eGFVID, options) {
            return localVarFp.registriesRecognizedRegistriesGet(namespaceVID, eGFVID, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get resource data indicated by DID.
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRegistryVIDGet(registryVID, options) {
            return localVarFp.registriesRegistryVIDGet(registryVID, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Query this Trust Registry about its recognition of a specific Trust Registry. TODO: determine RoR (registry of registry) impacts here.
         * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registriesRegistryVIDRecognizedRegistriesGet(registryVID, options) {
            return localVarFp.registriesRegistryVIDRecognizedRegistriesGet(registryVID, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RegistryApiFactory = RegistryApiFactory;
/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
class RegistryApi extends base_1.BaseAPI {
    /**
     *
     * @summary Determine whether an Entity has a particular Authorization.
     * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
     * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    entitiesEntityVIDAuthorizationGet(entityVID, authorizationVID, options) {
        return (0, exports.RegistryApiFp)(this.configuration).entitiesEntityVIDAuthorizationGet(entityVID, authorizationVID, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Determine whether an Entity has a particular Authorization.
     * @param {string} entityVID The VID-based identifier of a VID/DID/AID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    entitiesEntityVIDAuthorizationsGet(entityVID, options) {
        return (0, exports.RegistryApiFp)(this.configuration).entitiesEntityVIDAuthorizationsGet(entityVID, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns Registry Information about a particular entity that is represented in the queried system.
     * @param {string} entityid The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
     * @param {string} [authorizationVID] The identifier of the Authorization that is being queried for this Entity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    entititiesEntityidGet(entityid, authorizationVID, options) {
        return (0, exports.RegistryApiFp)(this.configuration).entititiesEntityidGet(entityid, authorizationVID, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Query this Trust Registry about its recognition of another Trust Registry.
     * @param {string} [namespaceVID] Filter in only the namespace requested - show all registries otherwise. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI.
     * @param {string} [eGFVID] Filter in only the registries under the specified EGF (by EGF DID). Defaults to be limited to the EGFURI that is being queried at the root. The URI-based Verifiable Identifier (VID) (e.g. DID or X.509 VID). Allows reserved characters per RFC3986. Do **NOT** escape the URI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    registriesRecognizedRegistriesGet(namespaceVID, eGFVID, options) {
        return (0, exports.RegistryApiFp)(this.configuration).registriesRecognizedRegistriesGet(namespaceVID, eGFVID, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get resource data indicated by DID.
     * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    registriesRegistryVIDGet(registryVID, options) {
        return (0, exports.RegistryApiFp)(this.configuration).registriesRegistryVIDGet(registryVID, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Query this Trust Registry about its recognition of a specific Trust Registry. TODO: determine RoR (registry of registry) impacts here.
     * @param {string} registryVID The URI-based identifier of a DID or X.509 Issuer. Allows reserved characters per RFC3986. Do **NOT** escape the URI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    registriesRegistryVIDRecognizedRegistriesGet(registryVID, options) {
        return (0, exports.RegistryApiFp)(this.configuration).registriesRegistryVIDRecognizedRegistriesGet(registryVID, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RegistryApi = RegistryApi;
//# sourceMappingURL=api.js.map